/**
 *
 * This is a language syntax draft for Omniarium
 *
**/

// [NOTE] Omniarium is not an independent programming language! It is strictly used to 
// generate high-level code specific to the user's project!
// [NOTE] You may define your own project libraries and import them using the "import" statement!
// To add a path for your library, you may use your project file (.omni.manifest) to include them.
// [NOTE] The "standard" library's only use is to help users generate code for common development
// targets - like plain web, or plain C++.

// Definitions:
// root-exclusive: can be used only at the top-level of the code tree!
// code-statement: any code that ends with a semicolon, a code block (scope), or a
// context separation (e.g. && or || conditions)

// Import platform filters
import @web, @java as @android from standard.target;
// Note that the "as" keyword will change the name of the imported component in the generated code!

// All custom libraries can be accessed by starting the package path with the word "library" 
import x, y, z from library.custom-lib;
// And custom libraries can have inner paths of their own
import Type-X, Type-Y, Type-Z from library.custom-lib.types;
// Registered custom standards can be accessed using the word "flavor" at the start of the package,
// followed by the standard's name!
import other-x from flavor.standard2.x;

// [NOTE] "import" statements are root-exclusive!

// All data that is meant to be imported using the "import" statement
// need to be exported using the "export" statement
export Integer a = 0;

// [NOTE] "export" statements are root-exclusive!

// [NOTE] Variables defined in the root-level of the code tree are global variables!
// Global variables are only accessible to the code within the same file, unless they are exported!
// [NOTE] Variables are only accessible to scopes/levels within the same, or a deeper, scope/level
// [NOTE] Variables are automatically freed from memory at the end of the scope/level they were
// defined in!

/**
 *
 * Filters are used to restrict a value's existence within the code tree!
 * Should a filter return a Boolean false state, whatever value or code block that comes
 * after said filter will be replaced with an 'empty' value. ('empty' acts the same as 'null')
 *
**/
filter @my-filter {
    // This filter includes this code if the target is either web or Java!
    @web @android
    return true;
    // else...
    return false;
}

// [NOTE] The symbol "#" is used to access transpiler compile-time values!
// Defined compile-time values are always strings!

filter @my-filter {
    // This is another way to implement this filter
    // (not recommended in normal circumstances,
    // only used by standard libraries)
    return (#target.is-web == "true" || #target.is-java == "true");
}

// [NOTE] "filter" statements are root-exclusive!

// [NOTE] "filter" statements are only processed at compile-time! Any variables
// used inside the filter's initial definition code block need to be defined at compile-time!

@my-filter
"hiiii";

// [NOTE] You can use filters only at the start of a code-statement

// If you are making a custom target, you may check its name/code!
filter @custom-target {
    // You may pass the custom target name to the transpiler on run time!
    return (#target.name == "transpiler-target-name");
    // But, if the target is based on an already existing target, you may
    // want to indicate so to the transpiler on run time! Otherwise, some
    // functions that your custom target depends on may become undefined!
}

// You can make custom filters that depend on build-time environment
// variables!
filter @project-filter {
    // You can use this to build multiple versions of your code on the same
    // target!
    return (#environment.IS_BETA == "true");
    // In your codebase root folder, you should have a file named "omni.environment"
    // that contains this value!
    // Alternatively, you could pass this value on build time in the CLI!
    // (e.g. "omni ... --env IS_BETA true")
}

/**
 *
 * The standard library shall include standard types, which can
 * handle all the supported target platforms.
 *
 * Notice that an empty Omni code file does not include any types by default!
 * 
 * List of planned types:
 * Numbers: Byte, Short, Integer, Long, Float, Double,
 * Text: String, Char,
 * Bool: Boolean,
 * Error Handling: Error,
 *
**/

// Standard types
import String, Integer from standard.type;

String b = "The value of integer a is '{a}'!";
// The value of the string b should be "The value of integer a is '0'!"

// You cannot add strings together using the plus or dot operators! You must only
// use this string concatenation method!
String string-a = "Hello there!";
String string-b = "Nice to meet you!";
String string-a-and-b = "{string-a} {string-b}";

// Arrays
import Array, Byte, Char from standard.type;

Array<Byte> bytes = new Array<Byte>(10); // a 'Byte' array with 10 items
Array<Byte,> double-bytes = new Array<Byte,>(10, 20); // a 'Byte' matrix with 10 rows and 20 columns

// The 'self' keyword
// The 'self' keyword refers to the type of the variable that is being defined!
Array<Byte,> double-bytes-2 = new self(10, 20); // Note that you can use the 'self' keyword to shorten the written code!

/**
 *
 * Filters can be used to write functions that do the same
 * thing on all different compilation targets!
 *
**/
@web
import get-dom-element-by-id, DOM-Element from standard.target.web;
@android
import get-java-element-by-id, Java-View from standard.target.java;

// [NOTE] "Good" Omni Libraries (not flavours) should aim to reduce the need for the user to specify
// a target filter as much as possible! Only standard and flavour libraries are meant to make use of
// the target filters!

/**
 *
 * Omni code values are typed, and this can be a problem when dealing with
 * more than one target platform. For that, you may define a type a type
 * according to the current target platform using filters!
 *
**/
type My-Type {
    String val;
    Char val2;
    ~define () {
        // Write code for when this type is defined!
    }
    ~delete () {
        // Write code for when this type is deleted/freed!
    }
}

// [NOTE] "type" statements are root-exclusive!

// You may define type aliases like this:
// An alias, set by the "is" keyword, does not exist on runtime! It is only processed at as a placeholder
// for the true type!
// You may use aliases with type definitions, variables, constants, and functions!
// [NOTE] The "is" keyword is mainly intended for use within library files!
// It is not recommended to use this keyword in normal project files!
type Elm-Obj is @web DOM-Element, @java Java-View;
// In this case, the first valid type in the list will be used as the 'true type' for the alias
String original-string = "Hi!";
String string-alias is original-string;
String original-function (Integer num) {
    return "My number is '{num}'!"
}
String function-alias (Integer my-number) is original-function; // Note that the alias function input variables' names can
                                            // differ, but their types and other related attributes should
                                            // remain the same!


// Functions!
Elm-Obj get-element (String id) {
    Elm-Obj elm;
    @web
    {
        elm = get-dom-element-by-id(id);
    }
    @android
    {
        // Java code
        // ...
        elm = get-java-element-by-id(id);
        /**
         *
         * You can inject native code into the result of your target platform!
         * (NEVER inject code without a target filter!)
         *
        **/
        inject {
            // you can inject native Java code!
        }
    }
    return elm;
}

// [NOTE] function definitions are root-exclusive!

Integer my-func () {
    // All this code above enables us to use one function
    // to write code for both targets @web and @android
    const Elm-Obj my-elm = get-element("my-id");
    Integer r;

    if (my-elm != empty) {
        r = 0;
    } else {
        r = 1;
    }

    // You can also free variables before the end of the function!
    delete my-elm;

    // Do some other stuff
    // ...

    return r;

    // [NOTE] Global variables are freed when this function is done executing!
}

// Run my-func() on start!
initial my-func;

// [NOTE] "initial" statement is root-exclusive!
// [NOTE] "initial" statement is a one-time use statement!

// You may define a function that doesn't return values as follows
// (notice that the Any & Void types are NOT supported)
empty-func (Integer a) {
    // do something with 'a'...
}

/**
 *
 * By default, any simple standard variable (with a simple standard type) received
 * in a function is duplicated, meaning that the function uses a variable that does
 * not share the same address as the input value!
 * 
 * But custom types and big data types (objects) are not duplicated, unless you indicate so!
 *
**/

add-one (borrow Integer num) {
    // You can borrow the variable itself without causing duplication!
    num++;
    // Note that borrowed variables (a.k.a. non-duplicate variables) are only freed
    // at the end of their original scope!
    // If you try to free the borrowed variable here, this will result in an error!
    delete num; // This will prevent your program from being compiled!
}
Integer test-num;
// The value of 'test-num' should change, because you lent the original variable to the function!
add-one(lend test-num);
// [NOTE] depending on your targeted language, the using of borrowing and lending may result in
// increased memory usage! So use this carefully! (e.g. if you borrow an integer, the final
// JavaScript code variable may hold the value inside an array, depening in the original code)

type Custom-Type {
    // Each type must make use of the 'traits' keyword
    // to define the behaviour of a custom data type and functions!
    traits {
        large-memory-use false; // If this is set to 'true', the variable will never
                                    // be duplicated when passed outside of its creation
                                    // scope, but the user will be required to make use
                                    // of the 'borrow' and 'lend' keywords in order to
                                    // pass this variable to other functions!
                                    // The default value is 'true'!
                                    // This trait can be used on types!
        deprecated false; // If this is set to 'true', the use will be warned when
                        // they used this data type in their code!
                        // The default value is 'false'!
                        // This trait can be used on types and functions!
        library-exclusive false; // If this is set to 'true', the user will be warned that this feature
                                // was intended only for building libraries and such.
                                // The default value is 'false'!
                                // This trait can be used on types and functions!
    }

    // Values used by this type!
    Integer a;

    // Functions that start with the symbol "~" are type event functions!
    // These functions are used to manage the behaviour of the data type!

    // The "~define" event function is a must-do for all types!
    ~define (Integer a) {
        this.a = a;
    }

    // Take care of deallocating memory!
    ~delete () {
        delete this.a;
    }

    // Do something when the value of the variable is called!
    ~retrieve () {
        // If you wish to define a custom behaviour when the value of this type if retrieved,
        // do so here!
    }

    // Define custom behaviour on lending and borrowing
    ~lend () {
        // ...
    }
    ~borrow () {
        // ...
    }
}
custom-add-one (Custom-Type obj) {
    obj.a++;
}
Custom-Type test-custom = new Custom-Type(0);
// Normally, the value of an integer inside a custom type should change!
// But because a this data type's "large-memory-use" trait is set to false, the value will not change
// unless it is borrowed!
custom-add-one(test-custom);

// [NOTE] Careful! You can't actually call functions on the root-level of the code tree!
// You need to call functions from within the initial function!

/**
 *
 * Error handling is done using the "try" and "catch" statements!
 *
**/

try {
    // Any errors thrown inside this 'try block' will be caught and handled by
    // the 'catch' block!

    // ...
    throw new Error("My error message!");
} catch (Error e) {
    // handle error!
    // ...
}

// [NOTE] You can't use the "try" and "catch" satements in the root level
// of the code tree!

/**
 *
 * Loops and conditional statements!
 *
**/

for (Integer i = 0; i < 10; i++) {
    // If statement
    if (...) {
        //
    } else if (...) {
        //
    } else {
        //
    }
    // Switch statement
    switch (i) {
        //
        case 1:
            // ..
            break;
        case 2:
            // ..
        default:
            // ..
    }
    // ...
}

do {
    // Run code, then check Boolean value!
    // ...
} while (true);

while (true) {
    // Check Boolean value, then run code!
    // ...
}

// [NOTE] You can't use "for" and "while" loops in the root level
// of the code tree!

// code-statement:
// (<Filter...>?) ... ({...}|CONTEXT_SEPARATION|;)

// [NOTE] Tabs, whitespace, and new lines are always ignored while parsing! As such,
// a 'code line' must always end with either a semi-colon (;) or a code block ({...})!
